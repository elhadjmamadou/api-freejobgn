========== ./manage.py ==========
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


========== ./extract_django_source.py ==========
import os
import fnmatch

# Définir les extensions à inclure et exclure
include_extensions = ['*.py', '*.html', '*.css', '*.js']
exclude_extensions = ['*.pyc']

# Dossiers à exclure (utiliser os.path.normpath pour la portabilité)
exclude_dirs = [
    'migrations',
    'myenv',
    'venv',
    'env',
    '__pycache__'
]

output_file = 'django_project_source.txt'

# Ouvrir le fichier de sortie en mode append (ajout)
with open(output_file, 'a', encoding='utf-8') as out:
    # Parcourir récursivement le répertoire courant
    for root, dirs, files in os.walk('.'):
        # Filtrer les dossiers à exclure (modifier dirs in-place pour skipper les sous-dirs)
        dirs[:] = [d for d in dirs if d not in exclude_dirs]
        
        for file in files:
            # Vérifier les extensions incluses et exclues
            if any(fnmatch.fnmatch(file, ext) for ext in include_extensions) and \
               not any(fnmatch.fnmatch(file, ext) for ext in exclude_extensions):
                
                full_path = os.path.join(root, file)
                print(f"Processing file: {full_path}")
                
                # Ajouter le séparateur avec le chemin
                out.write(f"========== {full_path} ==========\n")
                
                # Lire et écrire le contenu du fichier
                with open(full_path, 'r', encoding='utf-8') as f:
                    out.write(f.read())
                
                # Ajouter une ligne vide
                out.write("\n\n")


========== ./users/__init__.py ==========


========== ./users/views.py ==========
"""
Vues d'authentification pour l'API FreeJobGN.
"""

from django.conf import settings as django_settings
from django.contrib.auth import get_user_model
from django.utils import timezone
from rest_framework import status
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.throttling import AnonRateThrottle, UserRateThrottle
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework_simplejwt.exceptions import TokenError
from drf_spectacular.utils import extend_schema, OpenApiResponse, OpenApiExample

from .serializers import (
    RegisterSerializer,
    RegisterResponseSerializer,
    ActivationSerializer,
    ActivationResponseSerializer,
    ResendActivationSerializer,
    ResendActivationResponseSerializer,
    LoginSerializer,
    LoginResponseSerializer,
    TokenRefreshResponseSerializer,
    LogoutResponseSerializer,
    UserMeSerializer,
    ErrorResponseSerializer,
    RegistrationOptionsSerializer,
    PublicStatsSerializer,
)
from .tokens import activation_token_generator, decode_uid
from .emails import send_activation_email
from .models import UserRole, ProviderKind

User = get_user_model()


# ============================================================
# Throttling personnalisé
# ============================================================


class AuthAnonRateThrottle(AnonRateThrottle):
    """Rate limit pour les endpoints auth anonymes."""

    rate = "5/minute"

    def allow_request(self, request, view):
        # Désactiver le throttling en mode test
        if getattr(django_settings, "TESTING", False):
            return True
        return super().allow_request(request, view)


class AuthUserRateThrottle(UserRateThrottle):
    """Rate limit pour les endpoints auth authentifiés."""

    rate = "10/minute"

    def allow_request(self, request, view):
        # Désactiver le throttling en mode test
        if getattr(django_settings, "TESTING", False):
            return True
        return super().allow_request(request, view)


class ResendActivationThrottle(AnonRateThrottle):
    """Rate limit strict pour le renvoi d'activation."""

    rate = "3/hour"

    def allow_request(self, request, view):
        # Désactiver le throttling en mode test
        if getattr(django_settings, "TESTING", False):
            return True
        return super().allow_request(request, view)


# ============================================================
# Helper pour les cookies
# ============================================================


def get_refresh_cookie_settings():
    """Retourne les paramètres du cookie refresh token."""
    from django.conf import settings

    # En production, Secure=True et SameSite=None pour cross-origin
    # En dev, Secure=False et SameSite=Lax
    is_production = not getattr(settings, "DEBUG", True)

    return {
        "key": "refresh_token",
        "httponly": True,
        "secure": is_production,
        "samesite": "None" if is_production else "Lax",
        "path": "/api/auth/",  # Cookie uniquement pour les routes auth
    }


def set_refresh_cookie(response, refresh_token: str):
    """Ajoute le cookie refresh token à la réponse."""
    from django.conf import settings
    from datetime import timedelta

    cookie_settings = get_refresh_cookie_settings()
    refresh_lifetime_days = getattr(settings, "REFRESH_TOKEN_LIFETIME_DAYS", 7)

    response.set_cookie(
        key=cookie_settings["key"],
        value=str(refresh_token),
        max_age=int(timedelta(days=refresh_lifetime_days).total_seconds()),
        httponly=cookie_settings["httponly"],
        secure=cookie_settings["secure"],
        samesite=cookie_settings["samesite"],
        path=cookie_settings["path"],
    )


def delete_refresh_cookie(response):
    """Supprime le cookie refresh token."""
    cookie_settings = get_refresh_cookie_settings()
    response.delete_cookie(
        key=cookie_settings["key"],
        path=cookie_settings["path"],
        samesite=cookie_settings["samesite"],
    )


# ============================================================
# Vues d'authentification
# ============================================================


@extend_schema(tags=["Authentication"])
class RegisterView(APIView):
    """
    Inscription d'un nouvel utilisateur.

    Crée un compte inactif et envoie un email d'activation.
    """

    permission_classes = [AllowAny]
    throttle_classes = [AuthAnonRateThrottle]

    @extend_schema(
        request=RegisterSerializer,
        responses={
            201: RegisterResponseSerializer,
            400: OpenApiResponse(description="Erreur de validation"),
        },
        summary="Inscription utilisateur",
        description="Crée un nouveau compte utilisateur. Un email d'activation est envoyé.",
    )
    def post(self, request):
        serializer = RegisterSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        user = serializer.save()

        # Envoi de l'email d'activation
        email_sent = send_activation_email(user)

        return Response(
            {
                "message": "Compte créé avec succès. Vérifiez votre email pour activer votre compte.",
                "needs_activation": True,
                "email": user.email,
            },
            status=status.HTTP_201_CREATED,
        )


@extend_schema(tags=["Authentication"])
class ActivateView(APIView):
    """
    Activation du compte utilisateur via token.
    """

    permission_classes = [AllowAny]
    throttle_classes = [AuthAnonRateThrottle]

    @extend_schema(
        request=ActivationSerializer,
        responses={
            200: ActivationResponseSerializer,
            400: ErrorResponseSerializer,
        },
        summary="Activation du compte",
        description="Active le compte utilisateur avec le token reçu par email.",
    )
    def post(self, request):
        serializer = ActivationSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        uid = decode_uid(serializer.validated_data["uid"])
        token = serializer.validated_data["token"]

        if uid is None:
            return Response(
                {"detail": "Lien d'activation invalide."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        try:
            user = User.objects.get(pk=uid)
        except User.DoesNotExist:
            return Response(
                {"detail": "Lien d'activation invalide."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        # Vérifier si déjà actif
        if user.is_active:
            return Response(
                {"detail": "Ce compte est déjà activé."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        # Valider le token
        if not activation_token_generator.validate_token(user, token):
            # Vérifier si expiré pour un meilleur message
            if activation_token_generator.check_token_expired(token):
                return Response(
                    {
                        "detail": "Le lien d'activation a expiré. Demandez un nouveau lien."
                    },
                    status=status.HTTP_400_BAD_REQUEST,
                )
            return Response(
                {"detail": "Lien d'activation invalide."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        # Activer l'utilisateur
        user.is_active = True
        user.save(update_fields=["is_active"])

        return Response(
            {
                "message": "Compte activé avec succès. Vous pouvez maintenant vous connecter."
            },
            status=status.HTTP_200_OK,
        )


@extend_schema(tags=["Authentication"])
class ResendActivationView(APIView):
    """
    Renvoi de l'email d'activation.
    """

    permission_classes = [AllowAny]
    throttle_classes = [ResendActivationThrottle]

    @extend_schema(
        request=ResendActivationSerializer,
        responses={
            200: ResendActivationResponseSerializer,
            400: ErrorResponseSerializer,
        },
        summary="Renvoyer l'email d'activation",
        description="Renvoie l'email d'activation si le compte existe et n'est pas activé.",
    )
    def post(self, request):
        serializer = ResendActivationSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        email = serializer.validated_data["email"].lower()

        # Message générique pour ne pas divulguer l'existence des comptes
        success_message = (
            "Si un compte non activé existe avec cet email, "
            "un nouveau lien d'activation a été envoyé."
        )

        try:
            user = User.objects.get(email__iexact=email)
        except User.DoesNotExist:
            # On retourne succès même si le compte n'existe pas
            return Response({"message": success_message}, status=status.HTTP_200_OK)

        if user.is_active:
            # Compte déjà activé, on retourne quand même succès
            return Response({"message": success_message}, status=status.HTTP_200_OK)

        # Envoyer le nouvel email
        send_activation_email(user)

        return Response({"message": success_message}, status=status.HTTP_200_OK)


@extend_schema(tags=["Authentication"])
class LoginView(APIView):
    """
    Connexion utilisateur.

    Retourne un access token en JSON et set le refresh token en cookie HttpOnly.
    """

    permission_classes = [AllowAny]
    throttle_classes = [AuthAnonRateThrottle]

    @extend_schema(
        request=LoginSerializer,
        responses={
            200: LoginResponseSerializer,
            400: ErrorResponseSerializer,
            403: ErrorResponseSerializer,
        },
        summary="Connexion",
        description="Authentifie l'utilisateur et retourne les tokens JWT.",
    )
    def post(self, request):
        serializer = LoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        email = serializer.validated_data["email"].lower()
        password = serializer.validated_data["password"]

        try:
            user = User.objects.get(email__iexact=email)
        except User.DoesNotExist:
            return Response(
                {"detail": "Email ou mot de passe incorrect."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        if not user.check_password(password):
            return Response(
                {"detail": "Email ou mot de passe incorrect."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        # Vérifier si le compte est activé
        if not user.is_active:
            return Response(
                {
                    "detail": "Votre compte n'est pas activé. Vérifiez votre email ou demandez un nouveau lien d'activation.",
                    "needs_activation": True,
                    "email": user.email,
                },
                status=status.HTTP_403_FORBIDDEN,
            )

        # Générer les tokens JWT
        refresh = RefreshToken.for_user(user)
        access = str(refresh.access_token)

        # Préparer la réponse
        response_data = {
            "access": access,
            "user": UserMeSerializer(user).data,
        }

        response = Response(response_data, status=status.HTTP_200_OK)

        # Set le refresh token dans un cookie HttpOnly
        set_refresh_cookie(response, str(refresh))

        return response


@extend_schema(tags=["Authentication"])
class TokenRefreshView(APIView):
    """
    Rafraîchissement du token d'accès.

    Utilise le refresh token depuis le cookie HttpOnly.
    """

    permission_classes = [AllowAny]
    throttle_classes = [AuthUserRateThrottle]

    @extend_schema(
        request=None,
        responses={
            200: TokenRefreshResponseSerializer,
            401: ErrorResponseSerializer,
        },
        summary="Rafraîchir le token",
        description="Génère un nouveau access token à partir du refresh token (cookie).",
    )
    def post(self, request):
        refresh_token = request.COOKIES.get("refresh_token")

        if not refresh_token:
            return Response(
                {"detail": "Refresh token manquant."},
                status=status.HTTP_401_UNAUTHORIZED,
            )

        try:
            refresh = RefreshToken(refresh_token)

            # Rotation du refresh token (optionnel mais recommandé)
            # Génère un nouveau refresh token et blacklist l'ancien
            if hasattr(refresh, "blacklist"):
                try:
                    refresh.blacklist()
                except Exception:
                    pass  # Blacklist non configurée

            # Nouveau access token
            new_access = str(refresh.access_token)

            # Option: créer un nouveau refresh token pour rotation
            # new_refresh = RefreshToken.for_user(user)

            response = Response({"access": new_access}, status=status.HTTP_200_OK)

            # Si rotation activée, mettre à jour le cookie
            # set_refresh_cookie(response, str(new_refresh))

            return response

        except TokenError:
            response = Response(
                {"detail": "Refresh token invalide ou expiré."},
                status=status.HTTP_401_UNAUTHORIZED,
            )
            delete_refresh_cookie(response)
            return response


@extend_schema(tags=["Authentication"])
class LogoutView(APIView):
    """
    Déconnexion utilisateur.

    Supprime le cookie refresh token et optionnellement blacklist le token.
    """

    permission_classes = [AllowAny]  # Permet logout même avec token expiré

    @extend_schema(
        request=None,
        responses={
            200: LogoutResponseSerializer,
        },
        summary="Déconnexion",
        description="Déconnecte l'utilisateur et supprime le refresh token.",
    )
    def post(self, request):
        refresh_token = request.COOKIES.get("refresh_token")

        # Tenter de blacklister le token si possible
        if refresh_token:
            try:
                token = RefreshToken(refresh_token)
                if hasattr(token, "blacklist"):
                    token.blacklist()
            except TokenError:
                pass  # Token déjà invalide, on continue

        response = Response(
            {"message": "Déconnexion réussie."}, status=status.HTTP_200_OK
        )

        # Supprimer le cookie
        delete_refresh_cookie(response)

        return response


@extend_schema(tags=["Authentication"])
class MeView(APIView):
    """
    Informations de l'utilisateur connecté.
    """

    permission_classes = [IsAuthenticated]

    @extend_schema(
        responses={
            200: UserMeSerializer,
            401: ErrorResponseSerializer,
        },
        summary="Utilisateur courant",
        description="Retourne les informations de l'utilisateur authentifié.",
    )
    def get(self, request):
        serializer = UserMeSerializer(request.user)
        return Response(serializer.data, status=status.HTTP_200_OK)


# ============================================================
# Endpoints publics de métadonnées (stateless)
# ============================================================


@extend_schema(tags=["Public Metadata"])
class RegistrationOptionsView(APIView):
    """
    Options d'inscription disponibles.

    Endpoint public (AllowAny) pour permettre au frontend React
    d'afficher la page "Choisis ton rôle" avant l'inscription.

    Retourne:
    - Liste des rôles disponibles (CLIENT, PROVIDER)
    - Liste des types de prestataire (FREELANCE, AGENCY)
    - Règles de validation (provider_kind requis si role=PROVIDER)
    """

    permission_classes = [AllowAny]
    throttle_classes = []  # Pas de rate limiting pour les métadonnées

    @extend_schema(
        responses={
            200: OpenApiResponse(
                response=RegistrationOptionsSerializer,
                description="Options d'inscription récupérées avec succès.",
                examples=[
                    OpenApiExample(
                        name="Exemple de réponse",
                        summary="Options d'inscription complètes",
                        description="Retourne les rôles, types de prestataire et règles de validation.",
                        value={
                            "roles": [
                                {"value": "CLIENT", "label": "Client"},
                                {"value": "PROVIDER", "label": "Prestataire"},
                            ],
                            "provider_kinds": [
                                {"value": "FREELANCE", "label": "Freelance"},
                                {"value": "AGENCY", "label": "Agence"},
                            ],
                            "rules": {
                                "provider_kind_required_if_role": "PROVIDER",
                                "provider_kind_forbidden_if_role": "CLIENT",
                            },
                        },
                        response_only=True,
                    ),
                ],
            ),
        },
        summary="Options d'inscription",
        description=(
            "Retourne les options disponibles pour l'inscription: "
            "rôles, types de prestataire, et règles de validation. "
            "Endpoint public sans authentification."
        ),
    )
    def get(self, request):
        # Conversion des TextChoices en liste de dicts {value, label}
        roles = [{"value": choice.value, "label": choice.label} for choice in UserRole]
        provider_kinds = [
            {"value": choice.value, "label": choice.label} for choice in ProviderKind
        ]

        data = {
            "roles": roles,
            "provider_kinds": provider_kinds,
            "rules": {
                "provider_kind_required_if_role": UserRole.PROVIDER.value,
                "provider_kind_forbidden_if_role": UserRole.CLIENT.value,
            },
        }

        return Response(data, status=status.HTTP_200_OK)


@extend_schema(tags=["Public Metadata"])
class PublicStatsView(APIView):
    """
    Statistiques publiques.

    Endpoint public pour afficher des statistiques sur la landing page
    ou l'écran de choix de rôle.
    """

    permission_classes = [AllowAny]
    throttle_classes = []  # Pas de rate limiting pour les stats publiques

    @extend_schema(
        responses={
            200: PublicStatsSerializer,
        },
        summary="Statistiques publiques",
        description=(
            "Retourne des statistiques publiques sur les utilisateurs. "
            "Endpoint public sans authentification."
        ),
    )
    def get(self, request):
        # Compter uniquement les utilisateurs actifs
        clients_count = User.objects.filter(
            role=UserRole.CLIENT, is_active=True
        ).count()
        providers_count = User.objects.filter(
            role=UserRole.PROVIDER, is_active=True
        ).count()
        freelances_count = User.objects.filter(
            role=UserRole.PROVIDER,
            provider_kind=ProviderKind.FREELANCE,
            is_active=True,
        ).count()
        agencies_count = User.objects.filter(
            role=UserRole.PROVIDER,
            provider_kind=ProviderKind.AGENCY,
            is_active=True,
        ).count()

        data = {
            "clients_count": clients_count,
            "providers_count": providers_count,
            "freelances_count": freelances_count,
            "agencies_count": agencies_count,
        }

        return Response(data, status=status.HTTP_200_OK)


========== ./users/emails.py ==========
"""
Utilitaires pour l'envoi d'emails d'activation.
"""

from django.conf import settings
from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.utils.html import strip_tags

from .tokens import activation_token_generator, encode_uid


def send_activation_email(user) -> bool:
    """
    Envoie l'email d'activation à l'utilisateur.

    Args:
        user: Instance User à activer

    Returns:
        bool: True si l'email a été envoyé avec succès
    """
    # Génération du token et de l'uid encodé
    token = activation_token_generator.make_token(user)
    uid = encode_uid(user.pk)

    # URL d'activation pour le frontend
    frontend_url = getattr(settings, "FRONTEND_URL", "http://localhost:3000")
    activation_url = f"{frontend_url}/activate?uid={uid}&token={token}"

    # Contexte pour le template
    context = {
        "user": user,
        "activation_url": activation_url,
        "expiry_hours": getattr(settings, "ACTIVATION_TOKEN_EXPIRY_HOURS", 24),
        "site_name": "FreeJobGN",
    }

    # Sujet de l'email
    subject = "Activez votre compte FreeJobGN"

    # Message texte simple (fallback)
    message = f"""
Bonjour {user.username},

Merci de vous être inscrit sur FreeJobGN !

Pour activer votre compte, cliquez sur le lien ci-dessous :
{activation_url}

Ce lien expire dans {context['expiry_hours']} heures.

Si vous n'avez pas créé de compte sur FreeJobGN, ignorez cet email.

Cordialement,
L'équipe FreeJobGN
"""

    # Email HTML (optionnel, on utilise le texte simple pour l'instant)
    html_message = None
    try:
        html_message = render_to_string("users/emails/activation.html", context)
    except Exception:
        # Template non trouvé, on utilise le texte simple
        pass

    try:
        send_mail(
            subject=subject,
            message=message.strip(),
            from_email=getattr(settings, "DEFAULT_FROM_EMAIL", "noreply@freejobgn.com"),
            recipient_list=[user.email],
            html_message=html_message,
            fail_silently=False,
        )
        return True
    except Exception as e:
        # Log l'erreur en production
        import logging

        logger = logging.getLogger(__name__)
        logger.error(f"Erreur envoi email activation pour {user.email}: {e}")
        return False


========== ./users/tokens.py ==========
"""
Utilitaires pour la génération et validation des tokens d'activation.
Utilise les tokens signés Django (TimestampSigner) avec expiration.
"""

import base64
from datetime import timedelta

from django.conf import settings
from django.contrib.auth import get_user_model
from django.core.signing import TimestampSigner, BadSignature, SignatureExpired
from django.utils import timezone

User = get_user_model()


class AccountActivationTokenGenerator:
    """
    Générateur de tokens d'activation basé sur TimestampSigner.
    Le token est signé et contient un timestamp pour l'expiration.
    """

    def __init__(self):
        self.signer = TimestampSigner(salt="account-activation")

    def make_token(self, user) -> str:
        """
        Génère un token d'activation pour l'utilisateur.
        Le token inclut l'ID utilisateur et un hash de l'état du compte.
        """
        # On inclut is_active dans la signature pour invalider
        # automatiquement le token si l'utilisateur est déjà activé
        value = f"{user.pk}:{user.is_active}:{user.password[:20]}"
        return self.signer.sign(value)

    def validate_token(self, user, token: str) -> bool:
        """
        Valide un token d'activation.
        Retourne True si le token est valide et non expiré.
        """
        try:
            # Récupère la durée d'expiration depuis settings
            max_age_hours = getattr(settings, "ACTIVATION_TOKEN_EXPIRY_HOURS", 24)
            max_age = timedelta(hours=max_age_hours)

            # Décode et vérifie la signature + expiration
            value = self.signer.unsign(token, max_age=max_age)

            # Vérifie que le token correspond à l'état actuel
            expected = f"{user.pk}:{user.is_active}:{user.password[:20]}"
            return value == expected

        except SignatureExpired:
            return False
        except BadSignature:
            return False

    def check_token_expired(self, token: str) -> bool:
        """Vérifie si un token est expiré (pour messages d'erreur)."""
        try:
            max_age_hours = getattr(settings, "ACTIVATION_TOKEN_EXPIRY_HOURS", 24)
            max_age = timedelta(hours=max_age_hours)
            self.signer.unsign(token, max_age=max_age)
            return False
        except SignatureExpired:
            return True
        except BadSignature:
            return False  # Token invalide, pas expiré


def encode_uid(user_id: int) -> str:
    """Encode l'ID utilisateur en base64 URL-safe."""
    return base64.urlsafe_b64encode(str(user_id).encode()).decode()


def decode_uid(uid_b64: str) -> int | None:
    """Décode l'ID utilisateur depuis base64. Retourne None si invalide."""
    try:
        uid = base64.urlsafe_b64decode(uid_b64.encode()).decode()
        return int(uid)
    except (ValueError, TypeError, UnicodeDecodeError):
        return None


# Instance singleton du générateur
activation_token_generator = AccountActivationTokenGenerator()


========== ./users/models.py ==========
# users/models.py
from __future__ import annotations

import re
from django.conf import settings
from django.contrib.auth.models import AbstractUser
from django.core.exceptions import ValidationError
from django.db import models
from django.db.models import Q


# ============================================================
# Utils / Mixins
# ============================================================

class TimeStampedModel(models.Model):
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True


def upload_to_user_dir(instance, filename: str) -> str:
    """
    Stockage simple et stable pour médias.
    Ex: users/42/avatar.png
    """
    user_id = None
    if hasattr(instance, "user_id"):
        user_id = instance.user_id
    elif hasattr(instance, "provider_profile_id") and instance.provider_profile_id:
        user_id = instance.provider_profile.user_id
    elif hasattr(instance, "client_profile_id") and instance.client_profile_id:
        user_id = instance.client_profile.user_id
    return f"users/{user_id or 'unknown'}/{filename}"


# ============================================================
# Validators (anti-contact externe dans bio)
# ============================================================

EMAIL_RE = re.compile(r"[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}", re.I)
URL_RE = re.compile(r"https?://|www\.", re.I)
PHONE_RE = re.compile(r"(?:\+?\d[\s.-]?){7,}", re.I)

def validate_no_external_contact(value: str):
    if not value:
        return
    if EMAIL_RE.search(value) or URL_RE.search(value) or PHONE_RE.search(value):
        raise ValidationError("Pas de contact externe (email, téléphone, URL) dans la présentation.")


# ============================================================
# Référentiels
# ============================================================

class Skill(TimeStampedModel):
    name = models.CharField(max_length=80, unique=True)
    is_active = models.BooleanField(default=True)

    class Meta:
        ordering = ("name",)
        indexes = [models.Index(fields=["is_active", "name"])]

    def __str__(self) -> str:
        return self.name


class Speciality(TimeStampedModel):
    name = models.CharField(max_length=100, unique=True)
    description = models.CharField(max_length=200, blank=True)
    skills = models.ManyToManyField(Skill, related_name="specialities", blank=False)
    is_active = models.BooleanField(default=True)

    class Meta:
        ordering = ("name",)
        indexes = [models.Index(fields=["is_active", "name"])]

    def __str__(self) -> str:
        return self.name


# ============================================================
# User (auth + rôle)
# ============================================================

class UserRole(models.TextChoices):
    CLIENT = "CLIENT", "Client"
    PROVIDER = "PROVIDER", "Prestataire"


class ProviderKind(models.TextChoices):
    FREELANCE = "FREELANCE", "Freelance"
    AGENCY = "AGENCY", "Agence"


class User(AbstractUser, TimeStampedModel):
    """
    User = compte + auth + rôle (API-first)
    - username = pseudo (hérité AbstractUser)
    - email unique
    - role: client ou prestataire
    - provider_kind: freelance/agence si role=provider
    """
    email = models.EmailField("Adresse e-mail", unique=True)

    role = models.CharField(
        max_length=10,
        choices=UserRole.choices,
        db_index=True,
    )
    provider_kind = models.CharField(
        max_length=10,
        choices=ProviderKind.choices,
        null=True,
        blank=True,
        db_index=True,
        help_text="Uniquement si role=PROVIDER",
    )

    class Meta:
        constraints = [
            # provider_kind doit être défini seulement si role=PROVIDER
            models.CheckConstraint(
                name="user_provider_kind_consistency",
                condition=(
                    Q(role=UserRole.PROVIDER, provider_kind__isnull=False)
                    | Q(~Q(role=UserRole.PROVIDER), provider_kind__isnull=True)
                ),
            )
        ]
        indexes = [
            models.Index(fields=["role", "provider_kind"]),
            models.Index(fields=["email"]),
        ]

    def clean(self):
        super().clean()
        if self.role == UserRole.CLIENT and self.provider_kind is not None:
            raise ValidationError({"provider_kind": "Un client ne doit pas avoir provider_kind."})
        if self.role == UserRole.PROVIDER and self.provider_kind is None:
            raise ValidationError({"provider_kind": "Un prestataire doit avoir provider_kind (FREELANCE/AGENCY)."})

    @property
    def is_client(self) -> bool:
        return self.role == UserRole.CLIENT

    @property
    def is_provider(self) -> bool:
        return self.role == UserRole.PROVIDER

    @property
    def is_freelance(self) -> bool:
        return self.is_provider and self.provider_kind == ProviderKind.FREELANCE

    @property
    def is_agency(self) -> bool:
        return self.is_provider and self.provider_kind == ProviderKind.AGENCY

    def __str__(self) -> str:
        return f"{self.username} ({self.role})"


# ============================================================
# Provider (profil commun + détails)
# ============================================================

class ProviderProfile(TimeStampedModel):
    """
    Profil commun à tous les prestataires (Freelance + Agence)
    """
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="provider_profile",
    )

    profile_picture = models.ImageField(
        upload_to=upload_to_user_dir,
        blank=True,
        null=True,
    )

    bio = models.TextField(validators=[validate_no_external_contact])
    hourly_rate = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)

    city_or_region = models.CharField(max_length=120, db_index=True)
    country = models.CharField(max_length=120, db_index=True)
    postal_code = models.CharField(max_length=20, blank=True)
    phone = models.CharField(max_length=30, blank=True)

    # Référentiels
    skills = models.ManyToManyField(Skill, related_name="providers", blank=True)
    speciality = models.ForeignKey(
        Speciality,
        on_delete=models.PROTECT,
        related_name="providers",
        null=True,
        blank=True,
    )

    class Meta:
        indexes = [
            models.Index(fields=["country", "city_or_region"]),
            models.Index(fields=["hourly_rate"]),
        ]

    def clean(self):
        super().clean()
        if not self.user or not getattr(self.user, "is_provider", False):
            raise ValidationError("ProviderProfile réservé aux utilisateurs role=PROVIDER.")

        # hourly_rate conseillé (peut être obligatoire si vous voulez)
        # Ici on l'autorise null pour étape d'onboarding, mais on peut le forcer via serializer.
        if self.hourly_rate is not None and self.hourly_rate < 0:
            raise ValidationError({"hourly_rate": "hourly_rate ne peut pas être négatif."})

        # Validation speciality compatible avec skills:
        # ⚠️ En API, on recommande de faire ça dans le Serializer/Service (plus fiable).
        # Mais on garde une protection safe ici si la relation M2M existe déjà.
        if self.speciality_id and self.pk:
            skill_ids = set(self.skills.values_list("id", flat=True))
            if skill_ids:
                spec_skill_ids = set(self.speciality.skills.values_list("id", flat=True))
                if not (skill_ids & spec_skill_ids):
                    raise ValidationError({"speciality": "Spécialité incompatible avec vos skills."})

    def __str__(self) -> str:
        return f"ProviderProfile • {self.user.username}"


class FreelanceDetails(TimeStampedModel):
    """
    Détails spécifiques au freelance
    """
    provider_profile = models.OneToOneField(
        ProviderProfile,
        on_delete=models.CASCADE,
        related_name="freelance_details",
    )

    first_name = models.CharField(max_length=80)
    last_name = models.CharField(max_length=80)
    business_name = models.CharField(max_length=120, blank=True, help_text="Optionnel")

    class Meta:
        indexes = [models.Index(fields=["last_name", "first_name"])]

    def clean(self):
        super().clean()
        if not self.provider_profile or not self.provider_profile.user.is_freelance:
            raise ValidationError("FreelanceDetails réservé aux PROVIDER/FREELANCE.")

    def __str__(self) -> str:
        return f"FreelanceDetails • {self.provider_profile.user.username}"


class AgencyDetails(TimeStampedModel):
    """
    Détails spécifiques à l'agence
    """
    provider_profile = models.OneToOneField(
        ProviderProfile,
        on_delete=models.CASCADE,
        related_name="agency_details",
    )

    agency_name = models.CharField(max_length=150, db_index=True)
    founded_at = models.DateField(null=True, blank=True)

    class Meta:
        indexes = [models.Index(fields=["agency_name"])]

    def clean(self):
        super().clean()
        if not self.provider_profile or not self.provider_profile.user.is_agency:
            raise ValidationError("AgencyDetails réservé aux PROVIDER/AGENCY.")

    def __str__(self) -> str:
        return f"AgencyDetails • {self.agency_name}"


class AgencyDocumentType(models.TextChoices):
    RCCM = "RCCM", "RCCM"
    STATUTES = "STATUTES", "Statuts"
    OTHER = "OTHER", "Autre"


class AgencyDocument(TimeStampedModel):
    agency = models.ForeignKey(
        AgencyDetails,
        on_delete=models.CASCADE,
        related_name="documents",
    )
    doc_type = models.CharField(max_length=20, choices=AgencyDocumentType.choices, db_index=True)
    file = models.FileField(upload_to=upload_to_user_dir)
    reference_number = models.CharField(max_length=60, blank=True)

    class Meta:
        indexes = [
            models.Index(fields=["doc_type"]),
            models.Index(fields=["agency", "doc_type"]),
        ]

    def __str__(self) -> str:
        return f"{self.agency.agency_name} • {self.doc_type}"


class FreelanceDocumentType(models.TextChoices):
    # Freelance / général
    CV = "CV", "CV"
    CERTIFICATION = "CERTIFICATION", "Certification"
    PORTFOLIO = "PORTFOLIO", "Portfolio"
    IDENTITY = "IDENTITY", "Pièce d'identité"
    OTHER = "OTHER", "Autre"

    # Plutôt agence / légal
    RCCM = "RCCM", "RCCM"
    STATUTES = "STATUTES", "Statuts"
    TAX = "TAX", "Document fiscal"


class FreelanceDocument(TimeStampedModel):
    provider_profile = models.ForeignKey(
        ProviderProfile,
        on_delete=models.CASCADE,
        related_name="documents",
    )

    doc_type = models.CharField(
        max_length=20,
        choices=FreelanceDocumentType.choices,
        db_index=True,
    )

    file = models.FileField(upload_to=upload_to_user_dir)

    # champs utiles (API)
    title = models.CharField(max_length=120, blank=True)
    reference_number = models.CharField(max_length=60, blank=True)
    issued_at = models.DateField(null=True, blank=True)

    class Meta:
        indexes = [
            models.Index(fields=["doc_type"]),
            models.Index(fields=["provider_profile", "doc_type"]),
            models.Index(fields=["provider_profile", "created_at"]),
        ]

    def clean(self):
        super().clean()
        user = self.provider_profile.user

        # Exemple de règle stricte : RCCM/STATUTES réservés aux agences
        agency_only = {FreelanceDocumentType.RCCM, FreelanceDocumentType.STATUTES, FreelanceDocumentType.TAX}
        if user.is_freelance and self.doc_type in agency_only:
            raise ValidationError({"doc_type": "Ce type de document est réservé aux agences."})

        # Tu peux aussi décider l’inverse (CV réservé au freelance) si tu veux, mais souvent on laisse.

    def __str__(self) -> str:
        return f"{self.provider_profile.user.username} • {self.doc_type}"



# ============================================================
# Client (profil commun + sous-types)
# ============================================================

class ClientType(models.TextChoices):
    INDIVIDUAL = "INDIVIDUAL", "Particulier"
    COMPANY = "COMPANY", "Entreprise"


class ClientProfile(TimeStampedModel):
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="client_profile",
    )

    profile_picture = models.ImageField(
        upload_to=upload_to_user_dir,
        blank=True,
        null=True,
    )

    client_type = models.CharField(max_length=12, choices=ClientType.choices, db_index=True)

    city_or_region = models.CharField(max_length=120, db_index=True)
    country = models.CharField(max_length=120, db_index=True)
    postal_code = models.CharField(max_length=20, blank=True)
    phone = models.CharField(max_length=30, blank=True)

    class Meta:
        indexes = [
            models.Index(fields=["client_type"]),
            models.Index(fields=["country", "city_or_region"]),
        ]

    def clean(self):
        super().clean()
        if not self.user or not getattr(self.user, "is_client", False):
            raise ValidationError("ClientProfile réservé aux utilisateurs role=CLIENT.")

    def __str__(self) -> str:
        return f"ClientProfile • {self.user.username} ({self.client_type})"


class ClientIndividualDetails(TimeStampedModel):
    client_profile = models.OneToOneField(
        ClientProfile,
        on_delete=models.CASCADE,
        related_name="individual_details",
    )
    first_name = models.CharField(max_length=80)
    last_name = models.CharField(max_length=80)

    def clean(self):
        super().clean()
        if not self.client_profile or self.client_profile.client_type != ClientType.INDIVIDUAL:
            raise ValidationError("ClientIndividualDetails réservé aux clients INDIVIDUAL.")

    def __str__(self) -> str:
        return f"ClientIndividual • {self.first_name} {self.last_name}"


class ClientCompanyDetails(TimeStampedModel):
    client_profile = models.OneToOneField(
        ClientProfile,
        on_delete=models.CASCADE,
        related_name="company_details",
    )
    company_name = models.CharField(max_length=150, db_index=True)

    def clean(self):
        super().clean()
        if not self.client_profile or not self.client_profile.client_type != ClientType.COMPANY:
            raise ValidationError("ClientCompanyDetails réservé aux clients COMPANY.")

    def __str__(self) -> str:
        return f"ClientCompany • {self.company_name}"


class ClientCompanyDocumentType(models.TextChoices):
    RCCM = "RCCM", "RCCM"
    LEGAL = "LEGAL", "Document juridique"
    OTHER = "OTHER", "Autre"


class ClientCompanyDocument(TimeStampedModel):
    company = models.ForeignKey(
        ClientCompanyDetails,
        on_delete=models.CASCADE,
        related_name="documents",
    )
    doc_type = models.CharField(max_length=20, choices=ClientCompanyDocumentType.choices, db_index=True)
    file = models.FileField(upload_to=upload_to_user_dir)
    reference_number = models.CharField(max_length=60, blank=True)

    class Meta:
        indexes = [
            models.Index(fields=["doc_type"]),
            models.Index(fields=["company", "doc_type"]),
        ]

    def __str__(self) -> str:
        return f"{self.company.company_name} • {self.doc_type}"



========== ./users/admin.py ==========
"""
Configuration admin pour les modèles utilisateurs.
"""

from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.utils.translation import gettext_lazy as _

from .models import (
    User,
    Skill,
    Speciality,
    ProviderProfile,
    FreelanceDetails,
    AgencyDetails,
    AgencyDocument,
    FreelanceDocument,
    ClientProfile,
    ClientIndividualDetails,
    ClientCompanyDetails,
    ClientCompanyDocument,
)


@admin.register(User)
class UserAdmin(BaseUserAdmin):
    """Admin personnalisé pour le modèle User."""

    list_display = (
        "username",
        "email",
        "role",
        "provider_kind",
        "is_active",
        "is_staff",
        "date_joined",
    )
    list_filter = ("role", "provider_kind", "is_active", "is_staff", "date_joined")
    search_fields = ("username", "email")
    ordering = ("-date_joined",)

    fieldsets = (
        (None, {"fields": ("username", "password")}),
        (_("Informations personnelles"), {"fields": ("email",)}),
        (_("Rôle"), {"fields": ("role", "provider_kind")}),
        (
            _("Permissions"),
            {
                "fields": (
                    "is_active",
                    "is_staff",
                    "is_superuser",
                    "groups",
                    "user_permissions",
                ),
            },
        ),
        (_("Dates importantes"), {"fields": ("last_login", "date_joined")}),
    )

    add_fieldsets = (
        (
            None,
            {
                "classes": ("wide",),
                "fields": (
                    "username",
                    "email",
                    "password1",
                    "password2",
                    "role",
                    "provider_kind",
                ),
            },
        ),
    )


@admin.register(Skill)
class SkillAdmin(admin.ModelAdmin):
    list_display = ("name", "is_active", "created_at")
    list_filter = ("is_active",)
    search_fields = ("name",)
    ordering = ("name",)


@admin.register(Speciality)
class SpecialityAdmin(admin.ModelAdmin):
    list_display = ("name", "is_active", "created_at")
    list_filter = ("is_active",)
    search_fields = ("name", "description")
    filter_horizontal = ("skills",)
    ordering = ("name",)


class FreelanceDetailsInline(admin.StackedInline):
    model = FreelanceDetails
    can_delete = False
    extra = 0


class AgencyDetailsInline(admin.StackedInline):
    model = AgencyDetails
    can_delete = False
    extra = 0


class FreelanceDocumentInline(admin.TabularInline):
    model = FreelanceDocument
    extra = 0


@admin.register(ProviderProfile)
class ProviderProfileAdmin(admin.ModelAdmin):
    list_display = (
        "user",
        "country",
        "city_or_region",
        "hourly_rate",
        "speciality",
        "created_at",
    )
    list_filter = ("country", "speciality")
    search_fields = ("user__username", "user__email", "city_or_region")
    raw_id_fields = ("user", "speciality")
    filter_horizontal = ("skills",)
    inlines = [FreelanceDetailsInline, AgencyDetailsInline, FreelanceDocumentInline]


@admin.register(FreelanceDetails)
class FreelanceDetailsAdmin(admin.ModelAdmin):
    list_display = ("provider_profile", "first_name", "last_name", "business_name")
    search_fields = ("first_name", "last_name", "business_name")
    raw_id_fields = ("provider_profile",)


class AgencyDocumentInline(admin.TabularInline):
    model = AgencyDocument
    extra = 0


@admin.register(AgencyDetails)
class AgencyDetailsAdmin(admin.ModelAdmin):
    list_display = ("agency_name", "provider_profile", "founded_at")
    search_fields = ("agency_name",)
    raw_id_fields = ("provider_profile",)
    inlines = [AgencyDocumentInline]


class ClientIndividualDetailsInline(admin.StackedInline):
    model = ClientIndividualDetails
    can_delete = False
    extra = 0


class ClientCompanyDetailsInline(admin.StackedInline):
    model = ClientCompanyDetails
    can_delete = False
    extra = 0


@admin.register(ClientProfile)
class ClientProfileAdmin(admin.ModelAdmin):
    list_display = ("user", "client_type", "country", "city_or_region", "created_at")
    list_filter = ("client_type", "country")
    search_fields = ("user__username", "user__email", "city_or_region")
    raw_id_fields = ("user",)
    inlines = [ClientIndividualDetailsInline, ClientCompanyDetailsInline]


@admin.register(ClientIndividualDetails)
class ClientIndividualDetailsAdmin(admin.ModelAdmin):
    list_display = ("client_profile", "first_name", "last_name")
    search_fields = ("first_name", "last_name")
    raw_id_fields = ("client_profile",)


class ClientCompanyDocumentInline(admin.TabularInline):
    model = ClientCompanyDocument
    extra = 0


@admin.register(ClientCompanyDetails)
class ClientCompanyDetailsAdmin(admin.ModelAdmin):
    list_display = ("company_name", "client_profile")
    search_fields = ("company_name",)
    raw_id_fields = ("client_profile",)
    inlines = [ClientCompanyDocumentInline]


========== ./users/tests.py ==========
"""
Tests pour l'authentification.
"""

from django.test import TestCase, override_settings
from django.contrib.auth import get_user_model
from django.urls import reverse
from rest_framework.test import APITestCase, APIClient
from rest_framework import status

from .tokens import activation_token_generator, encode_uid, decode_uid
from .models import UserRole, ProviderKind

User = get_user_model()


class TokenTests(TestCase):
    """Tests pour les tokens d'activation."""

    def setUp(self):
        self.user = User.objects.create_user(
            username="testuser",
            email="test@example.com",
            password="TestPass123!",
            role=UserRole.CLIENT,
            is_active=False,
        )

    def test_encode_decode_uid(self):
        """Test encodage/décodage de l'uid."""
        uid_encoded = encode_uid(self.user.pk)
        uid_decoded = decode_uid(uid_encoded)
        self.assertEqual(self.user.pk, uid_decoded)

    def test_decode_invalid_uid(self):
        """Test décodage uid invalide."""
        self.assertIsNone(decode_uid("invalid"))
        self.assertIsNone(decode_uid(""))

    def test_token_generation(self):
        """Test génération de token."""
        token = activation_token_generator.make_token(self.user)
        self.assertIsNotNone(token)
        self.assertIsInstance(token, str)

    def test_token_validation_valid(self):
        """Test validation token valide."""
        token = activation_token_generator.make_token(self.user)
        is_valid = activation_token_generator.validate_token(self.user, token)
        self.assertTrue(is_valid)

    def test_token_validation_invalid(self):
        """Test validation token invalide."""
        is_valid = activation_token_generator.validate_token(self.user, "invalid-token")
        self.assertFalse(is_valid)

    def test_token_invalid_after_activation(self):
        """Test que le token est invalide après activation."""
        token = activation_token_generator.make_token(self.user)

        # Activer l'utilisateur
        self.user.is_active = True
        self.user.save()

        # Le token ne doit plus être valide
        is_valid = activation_token_generator.validate_token(self.user, token)
        self.assertFalse(is_valid)


@override_settings(TESTING=True)
class RegisterViewTests(APITestCase):
    """Tests pour l'inscription."""

    def setUp(self):
        self.url = reverse("users:register")
        self.valid_client_data = {
            "email": "newuser@example.com",
            "username": "newuser",
            "password": "SecurePass123!",
            "password_confirm": "SecurePass123!",
            "role": "CLIENT",
        }
        self.valid_provider_data = {
            "email": "provider@example.com",
            "username": "provider",
            "password": "SecurePass123!",
            "password_confirm": "SecurePass123!",
            "role": "PROVIDER",
            "provider_kind": "FREELANCE",
        }

    def test_register_client_success(self):
        """Test inscription client réussie."""
        response = self.client.post(self.url, self.valid_client_data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertTrue(response.data["needs_activation"])
        self.assertEqual(response.data["email"], "newuser@example.com")

        # Vérifier que l'utilisateur est créé mais inactif
        user = User.objects.get(email="newuser@example.com")
        self.assertFalse(user.is_active)
        self.assertEqual(user.role, UserRole.CLIENT)
        self.assertIsNone(user.provider_kind)

    def test_register_provider_success(self):
        """Test inscription prestataire réussie."""
        response = self.client.post(self.url, self.valid_provider_data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

        user = User.objects.get(email="provider@example.com")
        self.assertEqual(user.role, UserRole.PROVIDER)
        self.assertEqual(user.provider_kind, ProviderKind.FREELANCE)

    def test_register_provider_without_kind_fails(self):
        """Test inscription provider sans provider_kind échoue."""
        data = self.valid_provider_data.copy()
        del data["provider_kind"]
        response = self.client.post(self.url, data)
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("provider_kind", response.data)

    def test_register_client_with_kind_fails(self):
        """Test inscription client avec provider_kind échoue."""
        data = self.valid_client_data.copy()
        data["provider_kind"] = "FREELANCE"
        response = self.client.post(self.url, data)
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("provider_kind", response.data)

    def test_register_password_mismatch(self):
        """Test inscription avec mots de passe différents."""
        data = self.valid_client_data.copy()
        data["password_confirm"] = "DifferentPass123!"
        response = self.client.post(self.url, data)
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("password_confirm", response.data)

    def test_register_weak_password(self):
        """Test inscription avec mot de passe faible."""
        data = self.valid_client_data.copy()
        data["password"] = "123"
        data["password_confirm"] = "123"
        response = self.client.post(self.url, data)
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("password", response.data)

    def test_register_duplicate_email(self):
        """Test inscription avec email existant."""
        User.objects.create_user(
            username="existing",
            email="newuser@example.com",
            password="Test123!",
            role=UserRole.CLIENT,
        )
        response = self.client.post(self.url, self.valid_client_data)
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("email", response.data)


@override_settings(TESTING=True)
class ActivateViewTests(APITestCase):
    """Tests pour l'activation."""

    def setUp(self):
        self.url = reverse("users:activate")
        self.user = User.objects.create_user(
            username="testuser",
            email="test@example.com",
            password="TestPass123!",
            role=UserRole.CLIENT,
            is_active=False,
        )
        self.uid = encode_uid(self.user.pk)
        self.token = activation_token_generator.make_token(self.user)

    def test_activate_success(self):
        """Test activation réussie."""
        response = self.client.post(
            self.url,
            {
                "uid": self.uid,
                "token": self.token,
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        self.user.refresh_from_db()
        self.assertTrue(self.user.is_active)

    def test_activate_invalid_uid(self):
        """Test activation avec uid invalide."""
        response = self.client.post(
            self.url,
            {
                "uid": "invalid",
                "token": self.token,
            },
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_activate_invalid_token(self):
        """Test activation avec token invalide."""
        response = self.client.post(
            self.url,
            {
                "uid": self.uid,
                "token": "invalid-token",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_activate_already_active(self):
        """Test activation d'un compte déjà actif."""
        self.user.is_active = True
        self.user.save()

        response = self.client.post(
            self.url,
            {
                "uid": self.uid,
                "token": self.token,
            },
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("déjà activé", response.data["detail"])


@override_settings(TESTING=True)
class LoginViewTests(APITestCase):
    """Tests pour la connexion."""

    def setUp(self):
        self.url = reverse("users:login")
        self.user = User.objects.create_user(
            username="testuser",
            email="test@example.com",
            password="TestPass123!",
            role=UserRole.CLIENT,
            is_active=True,
        )
        self.inactive_user = User.objects.create_user(
            username="inactive",
            email="inactive@example.com",
            password="TestPass123!",
            role=UserRole.CLIENT,
            is_active=False,
        )

    def test_login_success(self):
        """Test connexion réussie."""
        response = self.client.post(
            self.url,
            {
                "email": "test@example.com",
                "password": "TestPass123!",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn("access", response.data)
        self.assertIn("user", response.data)

        # Vérifier le cookie refresh
        self.assertIn("refresh_token", response.cookies)
        self.assertTrue(response.cookies["refresh_token"]["httponly"])

    def test_login_wrong_password(self):
        """Test connexion avec mauvais mot de passe."""
        response = self.client.post(
            self.url,
            {
                "email": "test@example.com",
                "password": "WrongPass123!",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_login_wrong_email(self):
        """Test connexion avec email inexistant."""
        response = self.client.post(
            self.url,
            {
                "email": "nonexistent@example.com",
                "password": "TestPass123!",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)

    def test_login_inactive_user(self):
        """Test connexion utilisateur non activé."""
        response = self.client.post(
            self.url,
            {
                "email": "inactive@example.com",
                "password": "TestPass123!",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)
        self.assertTrue(response.data["needs_activation"])


@override_settings(TESTING=True)
class MeViewTests(APITestCase):
    """Tests pour /me."""

    def setUp(self):
        self.url = reverse("users:me")
        self.user = User.objects.create_user(
            username="testuser",
            email="test@example.com",
            password="TestPass123!",
            role=UserRole.PROVIDER,
            provider_kind=ProviderKind.FREELANCE,
            is_active=True,
        )

    def test_me_authenticated(self):
        """Test /me avec authentification."""
        self.client.force_authenticate(user=self.user)
        response = self.client.get(self.url)

        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data["email"], "test@example.com")
        self.assertEqual(response.data["role"], "PROVIDER")
        self.assertEqual(response.data["provider_kind"], "FREELANCE")

    def test_me_unauthenticated(self):
        """Test /me sans authentification."""
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)


@override_settings(TESTING=True)
class TokenRefreshViewTests(APITestCase):
    """Tests pour le refresh token."""

    def setUp(self):
        self.url = reverse("users:token-refresh")
        self.user = User.objects.create_user(
            username="testuser",
            email="test@example.com",
            password="TestPass123!",
            role=UserRole.CLIENT,
            is_active=True,
        )

    def test_refresh_success(self):
        """Test refresh token réussi."""
        # D'abord se connecter pour obtenir le cookie
        login_response = self.client.post(
            reverse("users:login"),
            {
                "email": "test@example.com",
                "password": "TestPass123!",
            },
        )
        self.assertEqual(login_response.status_code, status.HTTP_200_OK)

        # Maintenant refresh avec le cookie
        response = self.client.post(self.url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertIn("access", response.data)

    def test_refresh_without_cookie(self):
        """Test refresh sans cookie."""
        response = self.client.post(self.url)
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)


@override_settings(TESTING=True)
class LogoutViewTests(APITestCase):
    """Tests pour la déconnexion."""

    def setUp(self):
        self.url = reverse("users:logout")
        self.user = User.objects.create_user(
            username="testuser",
            email="test@example.com",
            password="TestPass123!",
            role=UserRole.CLIENT,
            is_active=True,
        )

    def test_logout_success(self):
        """Test déconnexion réussie."""
        # Se connecter d'abord
        self.client.post(
            reverse("users:login"),
            {
                "email": "test@example.com",
                "password": "TestPass123!",
            },
        )

        response = self.client.post(self.url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)

        # Le cookie doit être supprimé (valeur vide et expiration passée)
        self.assertIn("refresh_token", response.cookies)


@override_settings(TESTING=True)
class ResendActivationViewTests(APITestCase):
    """Tests pour le renvoi d'activation."""

    def setUp(self):
        self.url = reverse("users:resend-activation")
        self.inactive_user = User.objects.create_user(
            username="inactive",
            email="inactive@example.com",
            password="TestPass123!",
            role=UserRole.CLIENT,
            is_active=False,
        )
        self.active_user = User.objects.create_user(
            username="active",
            email="active@example.com",
            password="TestPass123!",
            role=UserRole.CLIENT,
            is_active=True,
        )

    def test_resend_inactive_user(self):
        """Test renvoi pour utilisateur inactif."""
        response = self.client.post(
            self.url,
            {
                "email": "inactive@example.com",
            },
        )
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_resend_active_user(self):
        """Test renvoi pour utilisateur déjà actif (pas d'info leak)."""
        response = self.client.post(
            self.url,
            {
                "email": "active@example.com",
            },
        )
        # Doit retourner succès pour ne pas divulguer l'existence du compte
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_resend_nonexistent_email(self):
        """Test renvoi pour email inexistant (pas d'info leak)."""
        response = self.client.post(
            self.url,
            {
                "email": "nonexistent@example.com",
            },
        )
        # Doit retourner succès pour ne pas divulguer l'existence du compte
        self.assertEqual(response.status_code, status.HTTP_200_OK)


# ============================================================
# Tests pour les endpoints publics de métadonnées
# ============================================================


class RegistrationOptionsViewTests(APITestCase):
    """Tests pour GET /api/auth/register/options/"""

    def setUp(self):
        self.url = reverse("users:register-options")

    def test_get_options_returns_200(self):
        """Test que l'endpoint retourne 200."""
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_get_options_contains_roles(self):
        """Test que la réponse contient les rôles."""
        response = self.client.get(self.url)
        data = response.json()

        self.assertIn("roles", data)
        self.assertIsInstance(data["roles"], list)
        self.assertEqual(len(data["roles"]), 2)

        # Vérifier structure
        role_values = [r["value"] for r in data["roles"]]
        self.assertIn("CLIENT", role_values)
        self.assertIn("PROVIDER", role_values)

        # Vérifier labels
        for role in data["roles"]:
            self.assertIn("value", role)
            self.assertIn("label", role)

    def test_get_options_contains_provider_kinds(self):
        """Test que la réponse contient les types de prestataire."""
        response = self.client.get(self.url)
        data = response.json()

        self.assertIn("provider_kinds", data)
        self.assertIsInstance(data["provider_kinds"], list)
        self.assertEqual(len(data["provider_kinds"]), 2)

        pk_values = [pk["value"] for pk in data["provider_kinds"]]
        self.assertIn("FREELANCE", pk_values)
        self.assertIn("AGENCY", pk_values)

    def test_get_options_contains_rules(self):
        """Test que la réponse contient les règles."""
        response = self.client.get(self.url)
        data = response.json()

        self.assertIn("rules", data)
        self.assertIsInstance(data["rules"], dict)
        self.assertEqual(data["rules"]["provider_kind_required_if_role"], "PROVIDER")
        self.assertEqual(data["rules"]["provider_kind_forbidden_if_role"], "CLIENT")

    def test_get_options_is_public(self):
        """Test que l'endpoint est accessible sans authentification."""
        # Pas de token, pas de session
        client = APIClient()
        response = client.get(self.url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)


class PublicStatsViewTests(APITestCase):
    """Tests pour GET /api/auth/public/stats/"""

    def setUp(self):
        self.url = reverse("users:public-stats")
        # Créer des utilisateurs de test
        User.objects.create_user(
            username="client1",
            email="client1@example.com",
            password="TestPass123!",
            role=UserRole.CLIENT,
            is_active=True,
        )
        User.objects.create_user(
            username="client2",
            email="client2@example.com",
            password="TestPass123!",
            role=UserRole.CLIENT,
            is_active=True,
        )
        User.objects.create_user(
            username="freelance1",
            email="freelance1@example.com",
            password="TestPass123!",
            role=UserRole.PROVIDER,
            provider_kind=ProviderKind.FREELANCE,
            is_active=True,
        )
        User.objects.create_user(
            username="agency1",
            email="agency1@example.com",
            password="TestPass123!",
            role=UserRole.PROVIDER,
            provider_kind=ProviderKind.AGENCY,
            is_active=True,
        )
        # Utilisateur inactif (ne doit pas être compté)
        User.objects.create_user(
            username="inactive",
            email="inactive@example.com",
            password="TestPass123!",
            role=UserRole.CLIENT,
            is_active=False,
        )

    def test_get_stats_returns_200(self):
        """Test que l'endpoint retourne 200."""
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)

    def test_get_stats_contains_counts(self):
        """Test que la réponse contient les compteurs."""
        response = self.client.get(self.url)
        data = response.json()

        self.assertIn("clients_count", data)
        self.assertIn("providers_count", data)
        self.assertIn("freelances_count", data)
        self.assertIn("agencies_count", data)

    def test_get_stats_correct_values(self):
        """Test que les compteurs sont corrects."""
        response = self.client.get(self.url)
        data = response.json()

        # 2 clients actifs (pas l'inactif)
        self.assertEqual(data["clients_count"], 2)
        # 2 providers (1 freelance + 1 agency)
        self.assertEqual(data["providers_count"], 2)
        self.assertEqual(data["freelances_count"], 1)
        self.assertEqual(data["agencies_count"], 1)

    def test_get_stats_excludes_inactive_users(self):
        """Test que les utilisateurs inactifs ne sont pas comptés."""
        # Ajouter un provider inactif
        User.objects.create_user(
            username="inactive_provider",
            email="inactive_provider@example.com",
            password="TestPass123!",
            role=UserRole.PROVIDER,
            provider_kind=ProviderKind.FREELANCE,
            is_active=False,
        )

        response = self.client.get(self.url)
        data = response.json()

        # Toujours 1 seul freelance actif
        self.assertEqual(data["freelances_count"], 1)

    def test_get_stats_is_public(self):
        """Test que l'endpoint est accessible sans authentification."""
        client = APIClient()
        response = client.get(self.url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)


========== ./users/apps.py ==========
from django.apps import AppConfig


class UsersConfig(AppConfig):
    name = 'users'


========== ./users/serializers.py ==========
"""
Serializers pour l'authentification et la gestion des utilisateurs.
"""

from django.contrib.auth import get_user_model
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError as DjangoValidationError
from rest_framework import serializers
from drf_spectacular.utils import extend_schema_field

from .models import UserRole, ProviderKind

User = get_user_model()


class RegisterSerializer(serializers.Serializer):
    """
    Serializer pour l'inscription d'un nouvel utilisateur.
    """

    email = serializers.EmailField(
        required=True, help_text="Adresse email unique de l'utilisateur"
    )
    username = serializers.CharField(
        required=True,
        min_length=3,
        max_length=150,
        help_text="Nom d'utilisateur unique",
    )
    password = serializers.CharField(
        write_only=True,
        required=True,
        style={"input_type": "password"},
        help_text="Mot de passe (minimum 8 caractères, avec complexité)",
    )
    password_confirm = serializers.CharField(
        write_only=True,
        required=True,
        style={"input_type": "password"},
        help_text="Confirmation du mot de passe",
    )
    role = serializers.ChoiceField(
        choices=UserRole.choices, required=True, help_text="Rôle: CLIENT ou PROVIDER"
    )
    provider_kind = serializers.ChoiceField(
        choices=ProviderKind.choices,
        required=False,
        allow_null=True,
        allow_blank=True,
        help_text="Type de prestataire: FREELANCE ou AGENCY (requis si role=PROVIDER)",
    )

    def validate_email(self, value):
        """Vérifie que l'email n'est pas déjà utilisé."""
        email_lower = value.lower()
        if User.objects.filter(email__iexact=email_lower).exists():
            raise serializers.ValidationError("Un compte avec cet email existe déjà.")
        return email_lower

    def validate_username(self, value):
        """Vérifie que le username n'est pas déjà utilisé."""
        if User.objects.filter(username__iexact=value).exists():
            raise serializers.ValidationError("Ce nom d'utilisateur est déjà pris.")
        return value

    def validate_password(self, value):
        """Valide la complexité du mot de passe avec les validators Django."""
        try:
            validate_password(value)
        except DjangoValidationError as e:
            raise serializers.ValidationError(list(e.messages))
        return value

    def validate(self, attrs):
        """Validation croisée des champs."""
        # Vérification correspondance mots de passe
        if attrs["password"] != attrs["password_confirm"]:
            raise serializers.ValidationError(
                {"password_confirm": "Les mots de passe ne correspondent pas."}
            )

        # Vérification cohérence role/provider_kind
        role = attrs.get("role")
        provider_kind = attrs.get("provider_kind")

        if role == UserRole.PROVIDER:
            if not provider_kind:
                raise serializers.ValidationError(
                    {
                        "provider_kind": "Le type de prestataire est requis pour un PROVIDER."
                    }
                )
        elif role == UserRole.CLIENT:
            if provider_kind:
                raise serializers.ValidationError(
                    {"provider_kind": "Un CLIENT ne doit pas avoir de provider_kind."}
                )
            # On force à None pour éviter les incohérences
            attrs["provider_kind"] = None

        return attrs

    def create(self, validated_data):
        """Crée l'utilisateur avec is_active=False."""
        validated_data.pop("password_confirm")
        password = validated_data.pop("password")

        user = User(
            email=validated_data["email"],
            username=validated_data["username"],
            role=validated_data["role"],
            provider_kind=validated_data.get("provider_kind"),
            is_active=False,  # Activation requise par email
        )
        user.set_password(password)
        user.full_clean()  # Valide les contraintes du modèle
        user.save()
        return user


class RegisterResponseSerializer(serializers.Serializer):
    """Serializer pour la réponse d'inscription."""

    message = serializers.CharField()
    needs_activation = serializers.BooleanField()
    email = serializers.EmailField()


class ActivationSerializer(serializers.Serializer):
    """Serializer pour l'activation du compte."""

    uid = serializers.CharField(
        required=True, help_text="Identifiant utilisateur encodé en base64"
    )
    token = serializers.CharField(required=True, help_text="Token d'activation signé")


class ActivationResponseSerializer(serializers.Serializer):
    """Serializer pour la réponse d'activation."""

    message = serializers.CharField()


class ResendActivationSerializer(serializers.Serializer):
    """Serializer pour renvoyer l'email d'activation."""

    email = serializers.EmailField(required=True, help_text="Email du compte à activer")


class ResendActivationResponseSerializer(serializers.Serializer):
    """Serializer pour la réponse de renvoi d'activation."""

    message = serializers.CharField()


class LoginSerializer(serializers.Serializer):
    """Serializer pour la connexion."""

    email = serializers.EmailField(required=True, help_text="Email de l'utilisateur")
    password = serializers.CharField(
        write_only=True,
        required=True,
        style={"input_type": "password"},
        help_text="Mot de passe",
    )


class LoginResponseSerializer(serializers.Serializer):
    """Serializer pour la réponse de connexion."""

    access = serializers.CharField(help_text="JWT Access Token")
    user = serializers.SerializerMethodField()

    @extend_schema_field(serializers.DictField())
    def get_user(self, obj):
        return obj.get("user", {})


class TokenRefreshResponseSerializer(serializers.Serializer):
    """Serializer pour la réponse de refresh token."""

    access = serializers.CharField(help_text="Nouveau JWT Access Token")


class LogoutResponseSerializer(serializers.Serializer):
    """Serializer pour la réponse de déconnexion."""

    message = serializers.CharField()


class UserMeSerializer(serializers.ModelSerializer):
    """Serializer pour les informations de l'utilisateur connecté."""

    class Meta:
        model = User
        fields = [
            "id",
            "email",
            "username",
            "role",
            "provider_kind",
            "is_active",
            "date_joined",
        ]
        read_only_fields = fields


class ErrorResponseSerializer(serializers.Serializer):
    """Serializer générique pour les erreurs."""

    detail = serializers.CharField()


class ValidationErrorResponseSerializer(serializers.Serializer):
    """Serializer pour les erreurs de validation."""

    # Les erreurs de validation sont un dict avec les champs comme clés
    pass


# ============================================================
# Serializers pour les endpoints de métadonnées publiques
# ============================================================


class ChoiceItemSerializer(serializers.Serializer):
    """Représente un choix (value + label)."""

    value = serializers.CharField(help_text="Valeur technique")
    label = serializers.CharField(help_text="Libellé affiché")


class RegistrationRulesSerializer(serializers.Serializer):
    """Règles de validation pour l'inscription."""

    provider_kind_required_if_role = serializers.CharField(
        help_text="Role pour lequel provider_kind est requis"
    )
    provider_kind_forbidden_if_role = serializers.CharField(
        help_text="Role pour lequel provider_kind est interdit"
    )


class RegistrationOptionsSerializer(serializers.Serializer):
    """
    Options d'inscription disponibles pour le frontend.
    Permet d'afficher la page "Choisis ton rôle" côté React.
    """

    roles = ChoiceItemSerializer(many=True, help_text="Liste des rôles disponibles")
    provider_kinds = ChoiceItemSerializer(
        many=True, help_text="Liste des types de prestataire"
    )
    rules = RegistrationRulesSerializer(
        help_text="Règles de validation role/provider_kind"
    )


class PublicStatsSerializer(serializers.Serializer):
    """Statistiques publiques pour la landing page."""

    clients_count = serializers.IntegerField(help_text="Nombre de clients inscrits")
    providers_count = serializers.IntegerField(
        help_text="Nombre de prestataires inscrits"
    )
    freelances_count = serializers.IntegerField(help_text="Nombre de freelances")
    agencies_count = serializers.IntegerField(help_text="Nombre d'agences")


========== ./users/urls.py ==========
"""
URLs pour l'authentification.
"""

from django.urls import path

from .views import (
    RegisterView,
    ActivateView,
    ResendActivationView,
    LoginView,
    TokenRefreshView,
    LogoutView,
    MeView,
    RegistrationOptionsView,
    PublicStatsView,
)

app_name = "users"

urlpatterns = [
    # Métadonnées publiques (stateless)
    path(
        "register/options/", RegistrationOptionsView.as_view(), name="register-options"
    ),
    path("public/stats/", PublicStatsView.as_view(), name="public-stats"),
    # Inscription et activation
    path("register/", RegisterView.as_view(), name="register"),
    path("activate/", ActivateView.as_view(), name="activate"),
    path(
        "resend-activation/", ResendActivationView.as_view(), name="resend-activation"
    ),
    # Authentification
    path("login/", LoginView.as_view(), name="login"),
    path("token/refresh/", TokenRefreshView.as_view(), name="token-refresh"),
    path("logout/", LogoutView.as_view(), name="logout"),
    # Utilisateur courant
    path("me/", MeView.as_view(), name="me"),
]


========== ./templates/users/emails/activation.html ==========
<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Activez votre compte - {{ site_name }}</title>
    <style>
      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu,
          sans-serif;
        line-height: 1.6;
        color: #333;
        max-width: 600px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }
      .container {
        background-color: #ffffff;
        border-radius: 8px;
        padding: 40px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .logo {
        text-align: center;
        margin-bottom: 30px;
      }
      .logo h1 {
        color: #2563eb;
        margin: 0;
        font-size: 28px;
      }
      h2 {
        color: #1f2937;
        margin-top: 0;
      }
      .button {
        display: inline-block;
        background-color: #2563eb;
        color: #ffffff !important;
        text-decoration: none;
        padding: 14px 28px;
        border-radius: 6px;
        font-weight: 600;
        margin: 20px 0;
      }
      .button:hover {
        background-color: #1d4ed8;
      }
      .footer {
        margin-top: 30px;
        padding-top: 20px;
        border-top: 1px solid #e5e7eb;
        font-size: 14px;
        color: #6b7280;
      }
      .warning {
        background-color: #fef3c7;
        border-left: 4px solid #f59e0b;
        padding: 12px 16px;
        margin: 20px 0;
        border-radius: 0 4px 4px 0;
      }
      .link-fallback {
        word-break: break-all;
        font-size: 12px;
        color: #6b7280;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="logo">
        <h1>🚀 {{ site_name }}</h1>
      </div>

      <h2>Bienvenue, {{ user.username }} !</h2>

      <p>Merci de vous être inscrit sur <strong>{{ site_name }}</strong>.</p>

      <p>
        Pour activer votre compte et commencer à utiliser notre plateforme,
        cliquez sur le bouton ci-dessous :
      </p>

      <p style="text-align: center">
        <a href="{{ activation_url }}" class="button">Activer mon compte</a>
      </p>

      <div class="warning">
        <strong>⏰ Important :</strong> Ce lien expire dans
        <strong>{{ expiry_hours }} heures</strong>.
      </div>

      <p class="link-fallback">
        Si le bouton ne fonctionne pas, copiez et collez ce lien dans votre
        navigateur :<br />
        <a href="{{ activation_url }}">{{ activation_url }}</a>
      </p>

      <div class="footer">
        <p>
          Si vous n'avez pas créé de compte sur {{ site_name }}, vous pouvez
          ignorer cet email en toute sécurité.
        </p>
        <p>Cordialement,<br /><strong>L'équipe {{ site_name }}</strong></p>
      </div>
    </div>
  </body>
</html>


========== ./config/asgi.py ==========
"""
ASGI config for config project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/6.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_asgi_application()


========== ./config/__init__.py ==========


========== ./config/settings.py ==========
"""
Django settings for config project.

Generated by 'django-admin startproject' using Django 6.0.1.

For more information on this file, see
https://docs.djangoproject.com/en/6.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/6.0/ref/settings/
"""

from pathlib import Path
from datetime import timedelta
from decouple import config, Csv

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/6.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = config(
    "SECRET_KEY", default="django-insecure-dev-only-change-me-in-production"
)

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = config("DEBUG", default=True, cast=bool)

ALLOWED_HOSTS = config("ALLOWED_HOSTS", default="localhost,127.0.0.1", cast=Csv())


# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "users",
    # Third-party
    "rest_framework",
    "rest_framework_simplejwt",
    "rest_framework_simplejwt.token_blacklist",  # Pour blacklister les refresh tokens
    "corsheaders",
    "drf_spectacular",
    "drf_spectacular_sidecar",
]

# Custom user model
AUTH_USER_MODEL = "users.User"

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "corsheaders.middleware.CorsMiddleware",  # CORS doit être avant CommonMiddleware
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "config.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "config.wsgi.application"


# Database
# https://docs.djangoproject.com/en/6.0/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}


# Password validation
# https://docs.djangoproject.com/en/6.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/6.0/topics/i18n/

LANGUAGE_CODE = "fr-fr"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/6.0/howto/static-files/

STATIC_URL = "static/"
STATIC_ROOT = BASE_DIR / "staticfiles"

# Media files (uploads)
MEDIA_URL = "media/"
MEDIA_ROOT = BASE_DIR / "media"

# Default primary key field type
DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"


# ============================================================
# Django REST Framework
# ============================================================

REST_FRAMEWORK = {
    "DEFAULT_SCHEMA_CLASS": "drf_spectacular.openapi.AutoSchema",
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    ),
    "DEFAULT_PERMISSION_CLASSES": ("rest_framework.permissions.IsAuthenticated",),
    # Throttling global (peut être overridé par vue)
    "DEFAULT_THROTTLE_CLASSES": [
        "rest_framework.throttling.AnonRateThrottle",
        "rest_framework.throttling.UserRateThrottle",
    ],
    "DEFAULT_THROTTLE_RATES": {
        "anon": "100/hour",
        "user": "1000/hour",
    },
    # Pagination par défaut
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 20,
    # Format de réponse
    "DEFAULT_RENDERER_CLASSES": [
        "rest_framework.renderers.JSONRenderer",
    ],
}

# En dev, ajouter le BrowsableAPI
if DEBUG:
    REST_FRAMEWORK["DEFAULT_RENDERER_CLASSES"].append(
        "rest_framework.renderers.BrowsableAPIRenderer"
    )


# ============================================================
# Simple JWT Configuration
# ============================================================

ACCESS_TOKEN_LIFETIME_MINUTES = config(
    "ACCESS_TOKEN_LIFETIME_MINUTES", default=15, cast=int
)
REFRESH_TOKEN_LIFETIME_DAYS = config("REFRESH_TOKEN_LIFETIME_DAYS", default=7, cast=int)

SIMPLE_JWT = {
    # Durées des tokens
    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=ACCESS_TOKEN_LIFETIME_MINUTES),
    "REFRESH_TOKEN_LIFETIME": timedelta(days=REFRESH_TOKEN_LIFETIME_DAYS),
    # Rotation des refresh tokens (recommandé pour la sécurité)
    "ROTATE_REFRESH_TOKENS": True,
    "BLACKLIST_AFTER_ROTATION": True,
    # Mise à jour du last_login à chaque refresh
    "UPDATE_LAST_LOGIN": True,
    # Algorithme de signature
    "ALGORITHM": "HS256",
    "SIGNING_KEY": SECRET_KEY,
    # Headers
    "AUTH_HEADER_TYPES": ("Bearer",),
    "AUTH_HEADER_NAME": "HTTP_AUTHORIZATION",
    # Claims
    "USER_ID_FIELD": "id",
    "USER_ID_CLAIM": "user_id",
    # Token type claim
    "TOKEN_TYPE_CLAIM": "token_type",
    "TOKEN_USER_CLASS": "rest_framework_simplejwt.models.TokenUser",
    # Sliding tokens (optionnel, non utilisé ici)
    "SLIDING_TOKEN_REFRESH_EXP_CLAIM": "refresh_exp",
    "SLIDING_TOKEN_LIFETIME": timedelta(minutes=5),
    "SLIDING_TOKEN_REFRESH_LIFETIME": timedelta(days=1),
}


# ============================================================
# CORS Configuration
# ============================================================

# URLs autorisées (frontend React)
CORS_ALLOWED_ORIGINS = config(
    "CORS_ALLOWED_ORIGINS",
    default="http://localhost:3000,http://127.0.0.1:3000",
    cast=Csv(),
)

# IMPORTANT: Permet l'envoi des cookies (refresh token)
CORS_ALLOW_CREDENTIALS = True

# Headers autorisés
CORS_ALLOW_HEADERS = [
    "accept",
    "accept-encoding",
    "authorization",
    "content-type",
    "dnt",
    "origin",
    "user-agent",
    "x-csrftoken",
    "x-requested-with",
]

# Méthodes autorisées
CORS_ALLOW_METHODS = [
    "DELETE",
    "GET",
    "OPTIONS",
    "PATCH",
    "POST",
    "PUT",
]


# ============================================================
# Email Configuration
# ============================================================

EMAIL_BACKEND = config(
    "EMAIL_BACKEND", default="django.core.mail.backends.console.EmailBackend"
)
EMAIL_HOST = config("EMAIL_HOST", default="localhost")
EMAIL_PORT = config("EMAIL_PORT", default=587, cast=int)
EMAIL_USE_TLS = config("EMAIL_USE_TLS", default=True, cast=bool)
EMAIL_HOST_USER = config("EMAIL_HOST_USER", default="")
EMAIL_HOST_PASSWORD = config("EMAIL_HOST_PASSWORD", default="")
DEFAULT_FROM_EMAIL = config("DEFAULT_FROM_EMAIL", default="noreply@freejobgn.com")


# ============================================================
# Frontend URL (pour les liens d'activation)
# ============================================================

FRONTEND_URL = config("FRONTEND_URL", default="http://localhost:3000")


# ============================================================
# Activation Token Expiry
# ============================================================

ACTIVATION_TOKEN_EXPIRY_HOURS = config(
    "ACTIVATION_TOKEN_EXPIRY_HOURS", default=24, cast=int
)


# ============================================================
# drf-spectacular Configuration
# ============================================================

SPECTACULAR_SETTINGS = {
    "TITLE": "FreeJobGN API",
    "DESCRIPTION": """
## API REST pour la plateforme FreeJobGN

### Authentification

Cette API utilise JWT (JSON Web Tokens) pour l'authentification.

**Workflow:**
1. **Inscription** (`POST /api/auth/register/`) - Crée un compte inactif
2. **Activation** (`POST /api/auth/activate/`) - Active le compte via le lien email
3. **Connexion** (`POST /api/auth/login/`) - Obtient un access token
4. **Accès API** - Utiliser `Authorization: Bearer <access_token>`
5. **Refresh** (`POST /api/auth/token/refresh/`) - Renouvelle l'access token

**Note:** Le refresh token est stocké dans un cookie HttpOnly pour la sécurité.
    """,
    "VERSION": "1.0.0",
    "SERVE_INCLUDE_SCHEMA": False,
    # Meilleure précision des schémas
    "COMPONENT_SPLIT_REQUEST": True,
    # Prefix pour les routes API
    "SCHEMA_PATH_PREFIX": r"/api",
    # Swagger UI settings
    "SWAGGER_UI_SETTINGS": {
        "deepLinking": True,
        "persistAuthorization": True,
        "displayOperationId": False,
        "filter": True,
    },
    # Tags pour organiser les endpoints
    "TAGS": [
        {"name": "Authentication", "description": "Inscription, connexion, activation"},
    ],
    # Sécurité JWT pour Swagger
    "SECURITY": [{"BearerAuth": []}],
    "SECURITY_DEFINITIONS": {
        "BearerAuth": {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT",
        }
    },
}


# ============================================================
# Logging (pour debug en dev)
# ============================================================

LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "verbose": {
            "format": "{levelname} {asctime} {module} {message}",
            "style": "{",
        },
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "verbose",
        },
    },
    "loggers": {
        "users": {
            "handlers": ["console"],
            "level": "DEBUG" if DEBUG else "INFO",
        },
    },
}


========== ./config/wsgi.py ==========
"""
WSGI config for config project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/6.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_wsgi_application()


========== ./config/urls.py ==========
from django.conf import settings
from django.conf.urls.static import static
from django.contrib import admin
from django.urls import path, include
from drf_spectacular.views import (
    SpectacularAPIView,
    SpectacularSwaggerView,
    SpectacularRedocView,
)

urlpatterns = [
    path("admin/", admin.site.urls),
    # API Auth endpoints
    path("api/auth/", include("users.urls", namespace="users")),
    # OpenAPI schema
    path("api/schema/", SpectacularAPIView.as_view(), name="schema"),
    # Swagger UI
    path("", SpectacularSwaggerView.as_view(url_name="schema"), name="swagger-ui"),
    # Redoc
    path("api/redoc/", SpectacularRedocView.as_view(url_name="schema"), name="redoc"),
]

# Servir les fichiers media en développement
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)


